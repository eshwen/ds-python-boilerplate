{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":"<p>Boilerplate for data science projects in Python. Check out the docs by clicking the badge above.</p>"},{"location":"general-python-tips/","title":"General Python tips","text":"<ul> <li>Use the built-in <code>pathlib</code> library for local file handling over <code>os.path</code></li> <li>Type hint functions and methods</li> <li>Run an async coroutine with <code>asyncio.run(&lt;call to coroutine&gt;)</code></li> <li>Follow Google's Python style guide: https://google.github.io/styleguide/pyguide.html</li> </ul>"},{"location":"helpful-articles/","title":"Helpful articles","text":"<ul> <li>Python versions in   Docker: https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d</li> <li>Emoji suggestions for git: https://gitmoji.dev/</li> <li>Semantic versioning: https://semver.org/</li> </ul>"},{"location":"see-also/","title":"See Also","text":"<p>Here are some shameless plugs of useful and/or interesting things I've made:</p> <ul> <li>phd-thesis: My PhD thesis in particle physics</li> <li>pyproject-version-sync: A pre-commit hook that keeps your <code>pyproject.toml</code> version in sync with your git repo's   latest tag</li> <li>macOS-setup: Files, instructions, and tidbits for setting up a new macOS machine</li> </ul>"},{"location":"getting-started/conda/","title":"Conda","text":""},{"location":"getting-started/conda/#conda","title":"Conda","text":"<ol> <li> <p>For a lightweight experience, install <code>miniconda</code>. This can be done through</p> Homebrew (on )Other <pre><code>brew install --cask miniconda\n</code></pre> <p>Figure it out </p> </li> <li> <p>Then initialise conda:</p> <pre><code>conda init \"$(basename \"${SHELL}\")\"\n&lt;exit and reopen terminal&gt;\n</code></pre> </li> <li> <p>Create your environment:</p> <pre><code>conda create -y -n my_project\nconda activate my_project\nconda config --set auto_activate_base false  # (1)\nconda install -y python=3.10  # (2)\npip install --upgrade pip\n</code></pre> <ol> <li>Stops automatically activating the <code>base</code> env when opening the terminal.</li> <li>This project also supports 3.11 - 3.13 if you want to use those instead.</li> </ol> </li> <li> <p>And finally, install the requirements:</p> <pre><code>cd &lt;root dir of project&gt;\npip install -r requirements.txt\npip install -r requirements-dev.txt\n</code></pre> </li> </ol>"},{"location":"getting-started/dev-container/","title":"Development Container","text":"<p>This project can be configured to be developed in a Docker container. This allows for a consistent development environment to be used across different machines and operating systems.</p>  Visual Studio Code PyCharm <ol> <li>Install the Remote - Containers extension (<code>ms-vscode-remote.remote-containers</code>)</li> <li>Open this project as a folder</li> <li>A prompt should appear to open it in a container. Ensure Docker is installed and running so the container can be    built.</li> </ol> <p>The devcontainer encompasses the following:</p> <ul> <li>Building the Docker container that contains a recent Python image</li> <li>Installing the project dependencies</li> <li>Installing VS Code workspace extensions</li> <li>Applying custom settings to aforementioned extensions</li> </ul> <ol> <li>Under the interpreters tab on the bottom row, hit Add New Interpreter -&gt; On Docker...<ol> <li>If the Docker server is blank, in the dropdown menu click Create new... -&gt; Ok</li> <li>Select the correct Dockerfile</li> <li>Set the Context folder to <code>.</code></li> <li>Uncheck the box Rebuild image automatically every time before running code</li> <li>Optionally, add an image tag to identify it later</li> </ol> </li> <li>Hit Next and let the container build</li> <li>On the final page, the default interpreter should be sufficient</li> </ol>"},{"location":"getting-started/getting-started/","title":"Installation","text":"<p>Check out the different methods of installing the project on the left-hand sidebar. Below are some programs that a data scientist may find useful.</p>"},{"location":"getting-started/getting-started/#programs","title":"Programs","text":"<ul> <li>Docker</li> <li>Visual Studio Code/PyCharm</li> <li>GitHub Desktop (optional)</li> </ul>  macOSOther <p><pre><code># Rosetta for compatibility with Intel\nsoftwareupdate --install-rosetta\n\n# Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install --cask docker\nbrew install --cask visual-studio-code  # or brew install --cask pycharm\nbrew install --cask github\n</code></pre> See https://github.com/eshwen/macOS-setup for more useful setup tips.</p> <p>Find the links on for these programs on the web </p>"},{"location":"getting-started/poetry/","title":"Poetry","text":""},{"location":"getting-started/poetry/#install-poetry","title":"Install Poetry","text":"<p>First, install Poetry. This can be done through</p>  Official installer Homebrew (on ) pip <p>See https://python-poetry.org/docs/#installation</p> <pre><code>brew install poetry\n</code></pre> <pre><code>pip install poetry\n</code></pre> <p>To ensure Poetry is up-to-date, run</p> <pre><code>poetry self update\n</code></pre> <p>Then, navigate to the project's root directory, and create the <code>virtualenv</code> environment with</p> <pre><code>poetry env use 3.10  # (1)\n</code></pre> <ol> <li>This project also supports 3.11 - 3.13 if you want to use those instead.</li> </ol> <p>In future sessions (on the CLI), you can enter the environment by navigating to the project's root directory and running</p> <pre><code>poetry shell\n</code></pre>"},{"location":"getting-started/poetry/#decoupling-python-and-poetry-installs","title":"Decoupling Python and Poetry installs","text":"<p>When installing Poetry, it will usually bundle a Python install. But when using Homebrew, it tends to automatically update Poetry and the Python dependency. If it upgrades the minor Python version - like 3.10 -&gt; 3.11 - it can break an existing environment.</p> <p>As such, it is best practice to decouple the Python install from Poetry. pyenv is a great, simple tool to manage Python installations.</p>  Homebrew (on )Other supported OS <pre><code>brew install pyenv\n</code></pre> <p>See https://github.com/pyenv/pyenv#installation.</p> <p>Then install a specific Python version. The executable path can be found with</p> <pre><code>pyenv which python\n</code></pre> <p>which can be used as the interpreter for the Poetry environment with</p> <pre><code>poetry env use \"$(pyenv which python)\"\n</code></pre> <p>Now you should have a static path to a specific Python install.</p> Tip <p>Run <code>poetry config virtualenvs.in-project true</code> to store the virtualenv in the project directory. This is useful if you want full visibility of the environment, instead of it being hidden elsewhere on your filesystem.</p>"},{"location":"getting-started/poetry/#install-the-project","title":"Install the project","text":"Command line PyCharm <p>To install everything from this project's Poetry configuration, run</p> <pre><code>poetry install\n</code></pre> <p>To only install the core dependencies, instead run</p> <pre><code>poetry install --without dev,test,docs\n</code></pre> <p>Since it will create a <code>virtualenv</code> environment for you, you don't need to run it in conjunction with another environment manager, such as conda.</p> <ol> <li>Open the project</li> <li>Click Add New Interpreter -&gt; Add Local Interpreter... -&gt; Poetry Environment</li> <li>Check Existing environment. The environment you just created should appear in the dropdown menu</li> </ol>"},{"location":"getting-started/poetry/#creating-your-own-configuration","title":"Creating your own configuration","text":"<p>To create your own Poetry configuration in pyproject.toml, run</p> <pre><code>poetry init\n</code></pre> <p>and follow the instructions. Then to port any dependencies from <code>requirements.txt</code> and <code>requirements-dev.txt</code>, run</p> <pre><code>cat requirements.txt | grep -E '^[^# ]' | cut -d= -f1 | xargs -n 1 poetry add\ncat requirements-dev.txt | grep -E '^[^# ]' | cut -d= -f1 | xargs -n 1 poetry add --group dev\n</code></pre> <p>Dependencies can be segmented into different groups. See pyproject.toml.</p> <p>It is recommended to maintain dependencies with Poetry, and export them (1) to <code>requirements.txt</code> and <code>requirements-dev.txt</code> if needed (2), e.g.,</p> <ol> <li>Exporting dependencies may require the plugin <code>poetry-plugin-export</code>. Install it    with <code>poetry self add poetry-plugin-export</code></li> <li>Check out quality#pre-commit for a pre-commit hook to do this    automatically.</li> </ol> <pre><code>poetry export --without-hashes -f requirements.txt -o requirements.txt\npoetry export --without-hashes --only dev -f requirements.txt -o requirements-dev.txt\n</code></pre> <p>This repo separates development dependencies into dev, tests, and docs groups. To export these, run</p> <pre><code>poetry export --without-hashes --only dev,test,docs -f requirements.txt -o requirements-dev.txt\n</code></pre>"},{"location":"tooling/documentation/","title":"Documentation","text":"<p>This repository uses Google-Style for docstrings. They are checked automatically by <code>ruff</code>. See quality for more information.</p>"},{"location":"tooling/documentation/#api-documentation","title":"API documentation","text":"<p>API documentation is built with MkDocs using the Material theme. The mike package wraps MkDocs and allows versioned sets of docs to be created. To build a static copy locally and render it live on a local server, run</p> MkDocs standaloneMkDocs with mike <pre><code>mkdocs serve\n</code></pre> <pre><code>mike serve\n</code></pre> <p>For a Sphinx implementation of documentation, see https://github.com/eshwen/ds-python-boilerplate/releases/tag/v0.1.1.</p>"},{"location":"tooling/documentation/#extensions-and-plugins","title":"Extensions and plugins","text":"<ul> <li>termynal: animated code blocks similar to the FastAPI docs<ul> <li>Installed as a Python package in pyproject.toml</li> <li>Added to the <code>plugins</code> section of mkdocs.yml</li> </ul> </li> </ul> python hello_world.py---&gt; Transmitting greeting...Hello world! <ul> <li>mkdocstrings: automatically generate API documentation from docstrings, like Sphinx's <code>autodoc</code><ul> <li>Installed as a Python package in pyproject.toml</li> <li>Added to the <code>plugins</code> section of mkdocs.yml</li> <li>Used alongside <code>mkdocs-gen-files</code> to automatically generate pages for all Python files in the repo<ul> <li>The script gen_ref_pages.py generates the Markdown files to populate the API docs</li> </ul> </li> <li>Used alongside <code>mkdocs-literate-nav</code> to pipe the navigation of the API docs to Markdown instead of YAML</li> <li>Used alongside <code>mkdocs-section-index</code> map the <code>__init__.py</code> files in each directory to the corresponding   section's <code>index.md</code></li> </ul> </li> </ul> <p>TODO: Add extension and plugin descriptions.</p>"},{"location":"tooling/pipelines/","title":"Pipelines","text":"<p>Several pipelines are included to execute automatically on various triggers:</p> What When How Check code with <code>ruff</code> and <code>mypy</code> On PR creation and subsequent pushes quality-check.yml Unit test with <code>pytest</code> On PR creation and subsequent pushes test.yml Build the API documentation On the creation of a new release api-docs.yml Check for dependency updates and vulnerabilities On a schedule (check the file) dependabot.yml Update the draft of the next release On pushes to <code>main</code> release-drafter.yml TODO <ul> <li>Add CodeQL pipeline.</li> <li>Flesh out dependabot more (package sets, etc.)</li> </ul>"},{"location":"tooling/quality/","title":"Quality","text":"<p>Quality checks are important for usable, readable code. They're often afterthoughts, but it's easy to configure and simply run tools to keep your code in tip-top shape.</p> <p>All the tools are documented below, and configured under the corresponding sections in pyproject.toml.</p>"},{"location":"tooling/quality/#ruff","title":"Ruff","text":"<p>Ruff is modern linter written in Rust. It's incredibly fast, and reimplements traditional linters and code checkers like <code>flake8</code>, <code>isort</code> (automatic import sorting), and <code>pydocstyle</code> (docstring checking).</p> <p>To only check your code, run</p> <pre><code>ruff check my_project/ tests/\n</code></pre> <p>To automatically fix any issues, run</p> <pre><code>ruff check --fix my_project/ tests/\n</code></pre> <p>Ruff now contains a formatter to replace Black. It ensures consistently-formatted, highly readable code.</p> <p>To automatically format your code, run</p> <pre><code>ruff format my_project/ tests/\n</code></pre> <p>To instead just show what <code>ruff</code> would change, run</p> <pre><code>ruff format --diff my_project/ tests/\n</code></pre>"},{"location":"tooling/quality/#pycharm-integration","title":"PyCharm integration","text":"<p>You can also install the Ruff plugin for PyCharm to run it automatically on file changes. In Preferences | Tools | Ruff, configure it as you like.</p> <p>To aid in documentation, in PyCharm go to Preferences | Tools | Python Integrated Tools. Under Docstrings, select the docstring format as Google.</p>"},{"location":"tooling/quality/#mypy","title":"Mypy","text":"<p>Mypy is a static type checker, examining object relationships and ensuring that they're used correctly (i.e., that type hints are correct).</p> <p>Run with</p> <pre><code>mypy my_project/\n</code></pre>"},{"location":"tooling/quality/#stubs","title":"Stubs","text":"<p>Some third-party libraries do not have type hints. In these cases, we can use stubs. These are <code>.pyi</code> files that provide (among other things) a statically-typed skeleton for the library. These should be automatically picked up by Mypy, and should complain if the necessary stubs aren't installed. Further information on stubs can be found in the Mypy docs: https://mypy.readthedocs.io/en/stable/stubs.html.</p> <p>If you need to install any stub packages, add them to the developer dependencies. You may also need to add them to the Mypy hook if you're using pre-commit (see .pre-commit-config.yaml).</p> Tip <p>Run the hook first, and see if it complains about any missing stubs. If you include a Mypy plugin (like <code>pydantic.mypy</code>) under <code>[tool.mypy]</code> in pyproject.toml, you will likely need to add the package for the hook.</p>"},{"location":"tooling/quality/#typing-extensions","title":"Typing extensions","text":"<p>Some libraries have type hints, but they are incomplete. In these cases, we can use typing extensions. These provide Python objects that can be used to type hint the missing functionality. For example, <code>boto3</code>:</p> <pre><code>import boto3\nimport mypy_boto3_s3\n\nresource: mypy_boto3_s3.S3ServiceResource = boto3.resource(\"s3\", ...)\n</code></pre> <p>Since we directly import these packages, they should be installed as normal dependencies.</p>"},{"location":"tooling/quality/#pre-commit","title":"pre-commit","text":"<p>pre-commit is a tool to run hooks before commits and pushes. When attempting to commit/push, the hooks will run in the background on the modified files. If issues are detected, the hooks will block the action and attempt to fix them, then you can try again.</p> <p>The .pre-commit-config.yaml file contains hooks to run</p> <ul> <li>built-in <code>pre-commit</code> checks</li> <li>Automatic use of the walrus operator</li> <li><code>ruff</code> for linting and formatting (fixes fixable issues)</li> <li><code>mypy</code> type-hinting errors</li> <li><code>poetry</code> dependency status (<code>poetry.lock</code> and requirements files are up-to-date)</li> </ul> <p>To use pre-commit, install the hooks with</p> <pre><code>pre-commit install\n</code></pre> <p>Then, when committing through PyCharm/GitHub Desktop/CLI, they should automatically run. Alternatively, run them manually with</p> <pre><code>pre-commit run -a\n</code></pre>"},{"location":"tooling/testing/","title":"Testing","text":"<p>Testing is an important part of any software development to ensure everything works intended. Critical code may change and break other functionality if coverage is not appropriate.</p>"},{"location":"tooling/testing/#unit-testing","title":"Unit testing","text":"<p>Unit testing is very straightforward with pytest. The configuration is stored in pyproject.toml.</p> <p>Run with</p> <pre><code>pytest my_project/\n</code></pre> <p>To get a nice coverage report (instead of the summary as part of the default configuration), run with</p> <pre><code>pytest --cov-report html my_project/\n</code></pre>"},{"location":"reference/my_project/","title":"my_project","text":"<p>This is the docstring for the my_project package.</p>"},{"location":"reference/my_project/hello_world/","title":"my_project.hello_world","text":"<p>Test file.</p>"},{"location":"reference/my_project/hello_world/#my_project.hello_world.do_a_dataframe_thing","title":"<code>do_a_dataframe_thing(df, arr=None)</code>","text":"<p>An example of documentation with references to external libraries.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input dataframe.</p> required <code>arr</code> <code>ndarray | None</code> <p>Input array.</p> <code>None</code> See Also <p>An explicit reference to a dataframe: pandas.DataFrame for an explicit reference. Or a numpy array: numpy.array.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with some magical operation applied to it.</p> Source code in <code>my_project/hello_world.py</code> <pre><code>def do_a_dataframe_thing(df: pd.DataFrame, arr: np.ndarray | None = None) -&gt; pd.DataFrame:\n    \"\"\"An example of documentation with references to external libraries.\n\n    Args:\n        df: Input dataframe.\n        arr: Input array.\n\n    See Also:\n        An explicit reference to a dataframe: [pandas.DataFrame][] for an explicit reference.\n        Or a numpy array: [numpy.array][].\n\n    Returns:\n         A dataframe with some magical operation applied to it.\n\n    \"\"\"\n    if arr is not None and arr.size &gt; 0:\n        return df[arr]\n    return df\n</code></pre>"},{"location":"reference/my_project/hello_world/#my_project.hello_world.hello_world","title":"<code>hello_world()</code>","text":"<p>Returns \"Hello World!\" when called.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string 'Hello world!'.</p> Example <pre><code>&gt;&gt;&gt; hello_world()\n'Hello World!'\n</code></pre> Note <p>This is an example of a note.</p> Warning <p>This is an example of a warning.</p> Source code in <code>my_project/hello_world.py</code> <pre><code>def hello_world() -&gt; str:\n    \"\"\"Returns \"Hello World!\" when called.\n\n    Returns:\n        str: The string 'Hello world!'.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; hello_world()\n        'Hello World!'\n        ```\n\n    Note:\n        This is an example of a note.\n\n    Warning:\n        This is an example of a warning.\n\n    \"\"\"\n    return \"Hello World!\"\n</code></pre>"}]}