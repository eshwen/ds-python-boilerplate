{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":"<p>Boilerplate for data science projects in Python. Check out the docs by clicking the badge above.</p>"},{"location":"documentation/","title":"Documentation","text":"<p>This repository uses Google-Style for documentation. Run <code>pydocstyle</code> to check the format of docstrings:</p> <pre><code>python -m pydocstyle --count --convention google --add-ignore D301,D212,D107 --match-dir '(?!(tests)).*' --match '(?!__init__).*\\.py'\n</code></pre>"},{"location":"documentation/#api-documentation","title":"API documentation","text":"<p>API documentation is built with MkDocs using the Material theme. To build a static copy locally, run</p> <pre><code>mkdocs build\n</code></pre> <p>Then open the homepage HTML file under <code>site/index.html</code>.</p> <p>Or, to render it live on a local server, run</p> <pre><code>mkdocs serve\n</code></pre> <p>For a Sphinx implementation of documentation, see https://github.com/eshwen/ds-python-boilerplate/releases/tag/v0.1.1.</p>"},{"location":"documentation/#extensions-and-plugins","title":"Extensions and plugins","text":"<ul> <li>termynal: animated code blocks similar to the FastAPI docs<ul> <li>Installed as a Python package   in pyproject.toml</li> <li>Added to the <code>plugins</code> section   of mkdocs.yml</li> </ul> </li> </ul> python hello_world.py---&gt; Transmitting greeting...Hello world! <p>TODO: Add extension and plugin descriptions.</p>"},{"location":"general-python-tips/","title":"General Python tips","text":"<ul> <li>Use the built-in <code>pathlib</code> library for local file handling over <code>os.path</code></li> <li>Type hint functions and methods</li> <li>Run an async coroutine with <code>asyncio.run(&lt;call to coroutine&gt;)</code></li> <li>Follow Google's Python style guide: https://google.github.io/styleguide/pyguide.html</li> </ul>"},{"location":"getting-started/","title":"Installation","text":""},{"location":"getting-started/#programs","title":"Programs","text":"<ul> <li>Docker</li> <li>Visual Studio Code/PyCharm</li> <li>GitHub Desktop (optional)</li> </ul>  macOSOther <p><pre><code># Rosetta for compatibility with Intel\nsoftwareupdate --install-rosetta\n\n# Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install --cask docker\nbrew install --cask visual-studio-code  # or brew install --cask pycharm\nbrew install --cask github\n</code></pre> See https://github.com/eshwen/macOS-setup for more useful setup tips.</p> <p>Find the links on for these programs on the web </p>"},{"location":"getting-started/#development-container","title":"Development Container","text":"Visual Studio Code PyCharm <ol> <li>Install the Remote - Containers extension (<code>ms-vscode-remote.remote-containers</code>)</li> <li>Open this project as a folder</li> <li>A prompt should appear to open it in a container. Ensure Docker is installed and running so the container can be built.</li> </ol> <p>The devcontainer encompasses the following:</p> <ul> <li>Building the Docker container that contains a recent Python image</li> <li>Installing the project dependencies</li> <li>Installing VS Code workspace extensions</li> <li>Applying custom settings to aforementioned extensions</li> </ul> <ol> <li>Under the interpreters tab on the bottom row, hit Add New Interpreter -&gt; On Docker...<ol> <li>If the Docker server is blank, in the dropdown menu click Create new... -&gt; Ok</li> <li>Select the correct Dockerfile</li> <li>Set the Context folder to <code>.</code></li> <li>Uncheck the box Rebuild image automatically every time before running code</li> <li>Optionally, add an image tag to identify it later</li> </ol> </li> <li>Hit Next and let the container build</li> <li>On the final page, the default interpreter should be sufficient</li> </ol>"},{"location":"getting-started/#poetry","title":"Poetry","text":""},{"location":"getting-started/#install-poetry","title":"Install Poetry","text":"<p>First, install Poetry. This can be done through</p> Official installerHomebrew (on )pip <p>See https://python-poetry.org/docs/#installation</p> <pre><code>brew install poetry\n</code></pre> <pre><code>pip install poetry\n</code></pre> <p>To ensure Poetry is up-to-date, run</p> <pre><code>poetry self update\n</code></pre> <p>Then, navigate to the project's root directory, and create the <code>virtualenv</code> environment with</p> <pre><code>poetry env use 3.10\n</code></pre> <p>In future sessions (on the CLI), you can enter the environment by navigating to the project's root directory and running</p> <pre><code>poetry shell\n</code></pre>"},{"location":"getting-started/#decoupling-python-and-poetry-installs","title":"Decoupling Python and Poetry installs","text":"<p>When installing Poetry, it will usually bundle a Python install. But when using Homebrew, it tends to automatically update Poetry and the Python dependency. If it upgrades the minor Python version - like 3.10 -&gt; 3.11 - it can break an existing environment.</p> <p>As such, it is best practice to decouple the Python install from Poetry. <code>pyenv</code> is a great, simple tool to manage Python installations.</p> Homebrew (on )Other supported OS <pre><code>brew install pyenv\n</code></pre> <p>See https://github.com/pyenv/pyenv#installation.</p> <p>Then install a specific Python version. The executable path can be found with</p> <pre><code>pyenv which python\n</code></pre> <p>which can be used as the interpreter for the Poetry environment with</p> <pre><code>poetry env use \"$(pyenv which python)\"\n</code></pre> <p>Now you should have a static path to a specific Python install.</p> Tip <p>Run <code>poetry config virtualenvs.in-project true</code> to store the virtualenv in the project directory. This is useful if you want full visibility of the environment, instead of it being hidden elsewhere on your filesystem.</p>"},{"location":"getting-started/#install-the-project","title":"Install the project","text":"Command line PyCharm <p>To install everything from this project's Poetry configuration, run</p> <pre><code>poetry install\n</code></pre> <p>To only install the core dependencies, instead run</p> <pre><code>poetry install --without dev,test,docs\n</code></pre> <p>Since it will create a <code>virtualenv</code> environment for you, you don't need to run it in conjunction with another environment manager, such as conda.</p> <ol> <li>Open the project</li> <li>Click Add New Interpreter -&gt; Add Local Interpreter... -&gt; Poetry Environment</li> <li>Check Existing environment. The environment you just created should appear in the dropdown menu</li> </ol>"},{"location":"getting-started/#creating-your-own-configuration","title":"Creating your own configuration","text":"<p>To create your own Poetry configuration in pyproject.toml, run</p> <pre><code>poetry init\n</code></pre> <p>and follow the instructions. Then to port any dependencies from <code>requirements.txt</code> and <code>requirements-dev.txt</code>, run</p> <pre><code>cat requirements.txt | grep -E '^[^# ]' | cut -d= -f1 | xargs -n 1 poetry add\ncat requirements-dev.txt | grep -E '^[^# ]' | cut -d= -f1 | xargs -n 1 poetry add --group dev\n</code></pre> <p>Dependencies can be segmented into different groups. See pyproject.toml.</p> <p>It is recommended to maintain dependencies with Poetry, and export them to <code>requirements.txt</code> and <code>requirements-dev.txt</code> if needed, e.g.,</p> <pre><code>poetry export --without-hashes -f requirements.txt -o requirements.txt\npoetry export --without-hashes --only dev -f requirements.txt -o requirements-dev.txt\n</code></pre> <p>This repo separates development dependencies into dev, tests, and docs groups. To export these, run</p> <pre><code>poetry export --without-hashes --only dev,test,docs -f requirements.txt -o requirements-dev.txt\n</code></pre>"},{"location":"getting-started/#conda","title":"Conda","text":"<ol> <li> <p>For a lightweight experience, install <code>miniconda</code>. This can be done through</p> Homebrew (on )Other <pre><code>brew install --cask miniconda\n</code></pre> <p>Figure it out </p> </li> <li> <p>Then initialise conda:</p> <pre><code>conda init \"$(basename \"${SHELL}\")\"\n&lt;exit and reopen terminal&gt;\n</code></pre> </li> <li> <p>Create your environment:</p> <pre><code>conda create -y -n my_project\nconda activate my_project\nconda config --set auto_activate_base false  # Don't automatically activate base env when opening terminal\nconda install -y python=3.10\npip install --upgrade pip\n</code></pre> </li> <li> <p>And finally, install the requirements:</p> <pre><code>cd &lt;root dir of project&gt;\npip install -r requirements.txt\npip install -r requirements-dev.txt\n</code></pre> </li> </ol>"},{"location":"helpful-articles/","title":"Helpful articles","text":"<ul> <li>Python versions in   Docker: https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d</li> <li>Emoji suggestions for git: https://gitmoji.dev/</li> <li>Semantic versioning: https://semver.org/</li> </ul>"},{"location":"linting-formatting/","title":"Linting and formatting","text":"<p>Both linting and formatting are important for usable, readable code. They're often afterthoughts, but it's easy to configure and simply run tools to keep your code in tip-top shape.</p> <p>All the tools are documented below, and configured under the corresponding sections in pyproject.toml.</p>"},{"location":"linting-formatting/#ruff","title":"ruff","text":"<p>ruff is modern linter written in Rust. It's incredibly fast, and reimplements traditional linters and code checkers like <code>flake8</code>, <code>isort</code> (automatic import sorting), and <code>pydocstyle</code> (docstring checking).</p> <p>To only check your code, run</p> <pre><code>ruff my_project/ tests/\n</code></pre> <p>To automatically fix any issues, run</p> <pre><code>ruff --fix my_project/ tests/\n</code></pre>"},{"location":"linting-formatting/#black","title":"black","text":"<p>black is a widely-used tool to ensure consistently-formatted code.</p> <p>To automatically reformat your code, run</p> <pre><code>black my_project/ tests/\n</code></pre> <p>To instead just show what <code>black</code> would change, run</p> <pre><code>black --diff my_project/ tests/\n</code></pre>"},{"location":"linting-formatting/#file-watchers-in-pycharm","title":"File watchers in PyCharm","text":"<p>PyCharm supports file watchers, which automatically run a command when a file is saved. This is useful for transparently formatting code.</p> <p>To include <code>black</code> as a file watcher, go to Settings -&gt; Tools -&gt; File Watchers and import the watchers.xml. This will automatically apply formatting to Python files and Jupyter notebooks. You may need to edit the Program path to point to your <code>black</code> executable.</p> <p>Otherwise, to set it up yourself, follow the instructions at https://black.readthedocs.io/en/stable/integrations/editors.html.</p> <p>Update: <code>black</code> is integrated into PyCharm as of v2023.2. Go to Settings -&gt; Tools -&gt; Black to configure.</p>"},{"location":"linting-formatting/#mypy","title":"mypy","text":"<p>mypy is a tool to check object types, such as correct type hinting.</p> <p>Run with</p> <pre><code>mypy my_project/ tests/\n</code></pre>"},{"location":"linting-formatting/#pre-commit","title":"pre-commit","text":"<p>pre-commit is a tool to run hooks before commits and pushes. When attempting to commit/push, the hooks will run in the background on the modified files. If issues are detected, the hooks will block the action and attempt to fix them, then you can try again.</p> <p>The .pre-commit-config.yaml file contains hooks to run</p> <ul> <li>built-in <code>pre-commit</code> checks</li> <li>Automatic use of the walrus operator</li> <li><code>pyupgrade</code> to use new Python syntax</li> <li><code>ruff</code> for linting (fixes fixable issues)</li> <li><code>black</code> for formatting (fixes fixable issues)</li> <li><code>mypy</code> type hinting errors</li> <li><code>poetry</code> status (<code>poetry.lock</code> and requirements files are up-to-date)</li> </ul> <p>To use pre-commit, install the hooks with</p> <pre><code>pre-commit install\n</code></pre> <p>Then, when committing through PyCharm/GitHub Desktop/CLI, they should automatically run. Alternatively, run them manually with</p> <pre><code>pre-commit run -a\n</code></pre>"},{"location":"pipelines/","title":"Pipelines","text":"<p>Several pipelines are included to execute automatically on various triggers:</p> <ul> <li>build.yml (to build the   project)</li> <li>dependabot.yml (to check for   updates and vulnerabilities in dependencies, the Docker container, and the other pipelines)</li> </ul> <p>TODO: Add documentation and CodeQL pipelines. TODO: Flesh out dependabot more (package sets, etc.) TODO: Flesh out build.yml more (coverage, unit tests, etc., and paths to scripts for local running - ensuring user does <code>chmod +x</code> on them if they are copying them over so they're executable with <code>./</code>).</p>"},{"location":"testing/","title":"Testing","text":"<p>Testing is an important part of any software development to ensure everything works intended. Critical code may change and break other functionality if coverage is not appropriate.</p>"},{"location":"testing/#unit-testing","title":"Unit testing","text":"<p>Unit testing is very straightforward with <code>pytest</code>. The configuration is stored in pyproject.toml.</p> <p>Run with</p> <pre><code>pytest my_project/\n</code></pre> <p>To get a nice coverage report (instead of the summary as part of the default configuration), run with</p> <pre><code>pytest --cov-report html my_project/\n</code></pre>"},{"location":"my_project/hello_world/","title":"hello_world","text":"<p>Test file.</p>"},{"location":"my_project/hello_world/#my_project.hello_world.do_a_dataframe_thing","title":"<code>do_a_dataframe_thing(df, arr=None)</code>","text":"<p>An example of documentation with references to external libraries.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input dataframe.</p> required <code>arr</code> <code>ndarray | None</code> <p>Input array.</p> <code>None</code> See Also <p>An explicit reference to a dataframe: pandas.DataFrame for an explicit reference. Or a numpy array: numpy.array.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with some magical operation applied to it.</p> Source code in <code>my_project/hello_world.py</code> <pre><code>def do_a_dataframe_thing(df: pd.DataFrame, arr: np.ndarray | None = None) -&gt; pd.DataFrame:\n\"\"\"An example of documentation with references to external libraries.\n    Args:\n        df: Input dataframe.\n        arr: Input array.\n    See Also:\n        An explicit reference to a dataframe: [pandas.DataFrame][] for an explicit reference.\n        Or a numpy array: [numpy.array][].\n    Returns:\n         A dataframe with some magical operation applied to it.\n    \"\"\"\nif arr is not None and arr.size &gt; 0:\nreturn df[arr]\nreturn df\n</code></pre>"},{"location":"my_project/hello_world/#my_project.hello_world.hello_world","title":"<code>hello_world()</code>","text":"<p>Returns \"Hello World!\" when called.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string 'Hello world!'.</p> Example <pre><code>&gt;&gt;&gt; hello_world()\n'Hello World!'\n</code></pre> Note <p>This is an example of a note.</p> Warning <p>This is an example of a warning.</p> Source code in <code>my_project/hello_world.py</code> <pre><code>def hello_world() -&gt; str:\n\"\"\"Returns \"Hello World!\" when called.\n    Returns:\n        str: The string 'Hello world!'.\n    Example:\n        ```python\n        &gt;&gt;&gt; hello_world()\n        'Hello World!'\n        ```\n    Note:\n        This is an example of a note.\n    Warning:\n        This is an example of a warning.\n    \"\"\"\nreturn \"Hello World!\"\n</code></pre>"}]}